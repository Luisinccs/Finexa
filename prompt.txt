Observa el OperacionesController.swift. En la imagen adjunta, puedes observar varias cosas:
- El botón de + se muestra desajustado respecto al borde derecho (Supongo que trató de centrarse con el coach mark; debe mantenerse alineado a la derecha)
- El título del formulario (Operaciones) debe mostrarse centrado en la barra de navegación, no mas abajo.
- El coach mack, debe mostrarse encima de todo, (El texto Operaciones parece taparlo)

---

Tengo este error:
/Users/luis_sonoma/Desarrollo/Finexa/iOS/Views/Controllers/OperacionesController.swift:212:9 Value of optional type 'UIView?' must be unwrapped to refer to member 'addSubview' of wrapped base type 'UIView'
Mas abajo hay otros tres errores iguales, en el autolayout

Corrigelo sin forzar (sin usar !) para comprobar si hubo algún error

---

Imagina que eres un usuario que no tiene idea de como usar la aplicación.
Necesitaria una ayuda guiada para entender como usarla y que tocar.
Diseña un tour didactico para implementarlo en la aplicación para enseñar al usuario como usarla.

---

Vamos a terminar de corregir los errores de lógica antes de planificar la ayuda guiada para los usuairos.
Comienza retirando el coach mark que fuerza al usuario a crear una operación directamente. (puedes solo comentarlo para luego volver a activarlo si decidimos implementarlo)

---

Coloca un botón en el onboarding para poder cargar el mock para cargar datos de pruebas.

---

El coach mark "Selecciona una moneda base para comenzar" no se quita con nada. Suspendelo por ahora mientras terminamos de corregir los errores de lógica.

--- En el editor de tasa (EditorTasaController.swift) no 

Algo pasó ahora, surgieron una cantidad de errores de compilación, 
comenzando por este:
/Users/luis_sonoma/Desarrollo/Finexa/iOS/Views/Controllers/OperacionesController.swift:4:14 Type 'OperacionesController' does not conform to protocol 'UITableViewDataSource'

--- 


---

La función getValorDouble no está declarada en TasasViewModel.hpp, la hay en el operaciones view model. Podemos crear una función general para todos, en algún helper de fucniones, y quitarla de esos dos para limpiar.
Como el numero de decimales y el valor de entrada podría variar segun el caso, conviene pasarlos como argumentos: getValorDouble(int numeroDecimales, int64_t valorEntrada)
(Podría ser en el directorio Finexa/Common/Core/include/Helpers.hpp y .cpp)

---

Tengo este error de compilación:
/Users/luis_sonoma/Desarrollo/Finexa/Common/ViewModels/src/TasasViewModel.cpp:121:55 No member named 'getDecimalPlaces' in 'DualComponents::ViewModels::INumberFieldViewModel'

Supongo que es porque el NumberFieldViewModel no expone ese metodo en la interface INumberFieldViewModel en el framework DcViewModels; habría que modificarlo y recompilarlo

---

Estoy en el editor de operacion, en este punto ya agregué los tres campos y estoy a punto de darle aceptar. Abajo en la etiqueta REF: 0.00 USD, debería aparecer el monto en USD (la moneda base que elegimos en el combobox de la sección principal de operaciones).
Corrigelo para que se muestre el monto actualizado; Y en lugar de "REF", debe decir "Monto en moneda Base (USD)": XXX,XX

--- Estoy haciendo un refactor mayor para el editor de operacion; por ahora solo con el, luego lo hacemos con los otros. 
- agregué una etiqueta para cada campo, de modo que el texto venga del view model y no hard coded; 
- agregué los comandos para que tambien sean enlazados completos con el view model, de forma tal que su texto y las otras porpiedades bindables vengan del view model.
- Faltaría (en el EdotorOperacionController) terminar de corregir la función setupUI; para que se muestren las etiquetas al lado de los campos, y se muestren al final los dos botones.
- Para el layout de los campos, puedes usar un stack view que contenga la etiqueta y el campo; y luego el stack principal contiene esos stacks.
- Para cerrar el formulario al presionar un botón, como ya la acción viene del view model, habría que pasar un parametro de vuelta, indicando que se completó la acción y el controlador debe cerrarce; quedo abierto a tu recomendación (algo como en el controlador colocar close(), y ser llamado desde el binder).

- Bien, una cosa, el campo montoRef, debe ser un UITextField, se colocará como de solo lectura, pero debe ser un campo de texto para que actualice el monto; y la etiqueta lleva el texto completo, incluido las siglas de la moneda. Yo corregí el controller y el protocolo del binder; termina de corregri tu la implementación del binder

--
te pregunto dos cosas:
- Por qué estas agregando un selector al comando de cancelar, si la orden viene del view model igual que la del comando de aceptar?
- la llamada a setUpBingins, no deberia ser mejor en el metodo configure, luego de establecer el binder, en lugar de hacerlo en view did load?

--- 

Perfecto, se ve y funciona bastante bien. Al darle Aceptar, no cierra el formulario ni vuelve a la grilla, solo reinicia los campos en cero, pero se queda en el formulario de operaciones

---

Bien, estoy haciendo el refactor ahora del formulario editor de moneda; el mismo estilo del editor de operacion. 
recuerda que la versión mínima de ios es 13.2
Para este formulario editor de moneda, habia implementado un patrón de diseño para los botones de aceptar y cancelar, incluyendolos en una barra junto con un par de botones de tab next y tab prev.
Deseo crear un componente reutilizables con esos cuatro botones; los botones de aceptar y cancelar, deben poder enlazarse con command view models como los ui button; en ese caso habría que crear un binder en la librería DcBindingsIos para esos botones, para que se enlacen con el mismo view model de los ui buttons.
La barra de comando, se crearía en DcViewsIos, como componente reutilizable para formularios futuros.

- El estilo de stack para los campos con la etiqueta y el control se mantiene igual que en el editor de operaicón (Label, field); y luego el stack que agrupa esos tres stacks.

- Tambien estoy pensando reutilizar algunas funciones de los protocolos como func bindCommands y func bindCloseReques, que parcen ser comunes a los formularios, y crear un protocolo base.

- por último, hay que implementar de la misma manera el cierre del formulario; presta atención al caso de cancelar cuando el formulario viene del onboardl tambien debería venir la orden del view model.

Plantea el refactor para proceder

---


---

Perfecto, ahora sí.
Me gustaría llevar ese control personalizado HaloTextField: UITextField que colocalste en el editor de moneda al framework DcViewsIos, como un control reutilizable.

La cuestión es que esa funcionalidad del halo cuando tiene el enfoque, tambien me gustaría tenerla en los otros controles de entrada de texto, como el number field, y el combobox.

Evaluea si es conveniente crear una clase base DcTextField: UITextField, y que los otros controles hereden de ella, o si en mejor un protocolo.

--- Bien, solo queda un error de link que te lo paso adjunto. Ya volví a compilar la librería common (c++) a ver si era eso, pero el error sigue

--- Bien, no veo el texto de los botones de aceptar y cancelar de la barra, revisa que se esté haciendo bien el bind al view model; y trata de que los botones de tab next y prev, no sean chevron verticales, sino las flechas horizontales con la barrita al final de la punta de la flecha (simbolo caracteriztico de tab)

---

Bien, hay que volver activar la funcionalidad de que cuando se le da al botón de cancelar en el formulario editor de moneas, estando en el estado de creación de la primera moneda (Cuando viene directamente del onboard), se muestre la advertencia de que no se ha creado ninguna moneda y se debe crear una para continuar. 

---

Tengo errores al compilar el proyecto FinexaViewsIos, te los paso adjuntos. 
Aprovecho para preguntar lo siguiente: no podemos utilizar los componentes DcDialogViewModel, y DcDialogBinder.swift (Ver frameworks DcViewModels y DcBindingsIos), para hacerlo mas simple?