Observa el OperacionesController.swift. En la imagen adjunta, puedes observar varias cosas:
- El botón de + se muestra desajustado respecto al borde derecho (Supongo que trató de centrarse con el coach mark; debe mantenerse alineado a la derecha)
- El título del formulario (Operaciones) debe mostrarse centrado en la barra de navegación, no mas abajo.
- El coach mack, debe mostrarse encima de todo, (El texto Operaciones parece taparlo)

---

Tengo este error:
/Users/luis_sonoma/Desarrollo/Finexa/iOS/Views/Controllers/OperacionesController.swift:212:9 Value of optional type 'UIView?' must be unwrapped to refer to member 'addSubview' of wrapped base type 'UIView'
Mas abajo hay otros tres errores iguales, en el autolayout

Corrigelo sin forzar (sin usar !) para comprobar si hubo algún error

---

Imagina que eres un usuario que no tiene idea de como usar la aplicación.
Necesitaria una ayuda guiada para entender como usarla y que tocar.
Diseña un tour didactico para implementarlo en la aplicación para enseñar al usuario como usarla.

---

Vamos a terminar de corregir los errores de lógica antes de planificar la ayuda guiada para los usuairos.
Comienza retirando el coach mark que fuerza al usuario a crear una operación directamente. (puedes solo comentarlo para luego volver a activarlo si decidimos implementarlo)

---

Coloca un botón en el onboarding para poder cargar el mock para cargar datos de pruebas.

---

El coach mark "Selecciona una moneda base para comenzar" no se quita con nada. Suspendelo por ahora mientras terminamos de corregir los errores de lógica.

--- En el editor de tasa (EditorTasaController.swift) no 

Algo pasó ahora, surgieron una cantidad de errores de compilación, 
comenzando por este:
/Users/luis_sonoma/Desarrollo/Finexa/iOS/Views/Controllers/OperacionesController.swift:4:14 Type 'OperacionesController' does not conform to protocol 'UITableViewDataSource'

--- 


---

La función getValorDouble no está declarada en TasasViewModel.hpp, la hay en el operaciones view model. Podemos crear una función general para todos, en algún helper de fucniones, y quitarla de esos dos para limpiar.
Como el numero de decimales y el valor de entrada podría variar segun el caso, conviene pasarlos como argumentos: getValorDouble(int numeroDecimales, int64_t valorEntrada)
(Podría ser en el directorio Finexa/Common/Core/include/Helpers.hpp y .cpp)

---

Tengo este error de compilación:
/Users/luis_sonoma/Desarrollo/Finexa/Common/ViewModels/src/TasasViewModel.cpp:121:55 No member named 'getDecimalPlaces' in 'DualComponents::ViewModels::INumberFieldViewModel'

Supongo que es porque el NumberFieldViewModel no expone ese metodo en la interface INumberFieldViewModel en el framework DcViewModels; habría que modificarlo y recompilarlo

---

Estoy en el editor de operacion, en este punto ya agregué los tres campos y estoy a punto de darle aceptar. Abajo en la etiqueta REF: 0.00 USD, debería aparecer el monto en USD (la moneda base que elegimos en el combobox de la sección principal de operaciones).
Corrigelo para que se muestre el monto actualizado; Y en lugar de "REF", debe decir "Monto en moneda Base (USD)": XXX,XX

--- Estoy haciendo un refactor mayor para el editor de operacion; por ahora solo con el, luego lo hacemos con los otros. 
- agregué una etiqueta para cada campo, de modo que el texto venga del view model y no hard coded; 
- agregué los comandos para que tambien sean enlazados completos con el view model, de forma tal que su texto y las otras porpiedades bindables vengan del view model.
- Faltaría (en el EdotorOperacionController) terminar de corregir la función setupUI; para que se muestren las etiquetas al lado de los campos, y se muestren al final los dos botones.
- Para el layout de los campos, puedes usar un stack view que contenga la etiqueta y el campo; y luego el stack principal contiene esos stacks.
- Para cerrar el formulario al presionar un botón, como ya la acción viene del view model, habría que pasar un parametro de vuelta, indicando que se completó la acción y el controlador debe cerrarce; quedo abierto a tu recomendación (algo como en el controlador colocar close(), y ser llamado desde el binder).

- Bien, una cosa, el campo montoRef, debe ser un UITextField, se colocará como de solo lectura, pero debe ser un campo de texto para que actualice el monto; y la etiqueta lleva el texto completo, incluido las siglas de la moneda. Yo corregí el controller y el protocolo del binder; termina de corregri tu la implementación del binder

--
te pregunto dos cosas:
- Por qué estas agregando un selector al comando de cancelar, si la orden viene del view model igual que la del comando de aceptar?
- la llamada a setUpBingins, no deberia ser mejor en el metodo configure, luego de establecer el binder, en lugar de hacerlo en view did load?

--- 

Perfecto, se ve y funciona bastante bien. Al darle Aceptar, no cierra el formulario ni vuelve a la grilla, solo reinicia los campos en cero, pero se queda en el formulario de operaciones